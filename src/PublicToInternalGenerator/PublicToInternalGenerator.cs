using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

[Generator]
public class PublicToInternalGenerator : IIncrementalGenerator
{
  public void Initialize(IncrementalGeneratorInitializationContext context)
  {
    // System.Diagnostics.Debugger.Launch();

    // Create a provider for additional files that end with "Annotations.cs"
    var additionalFilesProvider = context.AdditionalTextsProvider
      .Where(file => file.Path.EndsWith("Annotations.cs", StringComparison.OrdinalIgnoreCase));

    // Transform each additional file into a generated source
    var generatedSources = additionalFilesProvider
      .Select(ProcessFile)
      .Where(result => result != null); // Filter out null results

    // Register the source output
    context.RegisterSourceOutput(generatedSources, (sourceProductionContext, source) =>
    {
      if (source != null)
      {
        sourceProductionContext.AddSource(source.Value.fileName, source.Value.sourceText);
      }
    });
  }

  private static (string fileName, string sourceText)? ProcessFile(
    AdditionalText file, CancellationToken cancellationToken)
  {
    var sourceText = file.GetText(cancellationToken);
    if (sourceText == null) return null;

    var syntaxTree = CSharpSyntaxTree.ParseText(sourceText, cancellationToken: cancellationToken);
    var root = syntaxTree.GetCompilationUnitRoot(cancellationToken);

    var rewriter = new PublicToInternalRewriter();

    var newRoot = rewriter.Visit(root);
    if (newRoot == root) return null; // only generate if changes were made

    var sourceCode = newRoot.GetText(Encoding.UTF8).ToString();

    sourceCode = "// <auto-generated />\r\n" + sourceCode;

    const string nullableDisableDirective = "#nullable disable";

    if (!sourceCode.Contains(nullableDisableDirective))
      throw new Exception("Nullability directive expected!");

    sourceCode = sourceCode.Replace(
      nullableDisableDirective,
      $"#if NETCOREAPP3_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER\r\n{nullableDisableDirective}\r\n#endif");

    // when declared as 'partial' it should not clash with the user's Embedded attribute declaration
    sourceCode += "\r\nnamespace Microsoft.CodeAnalysis\r\n{\r\n  " +
                  "internal sealed partial class EmbeddedAttribute : global::System.Attribute { }\r\n}";

    var fileName = Path.GetFileNameWithoutExtension(file.Path);
    var newFileName = $"{fileName}.Internal.cs";

    return (newFileName, sourceCode);
  }
}

internal class PublicToInternalRewriter : CSharpSyntaxRewriter
{
  public override SyntaxNode? VisitAttributeList(AttributeListSyntax node)
  {
    // Remove [Conditional(...)] attributes from any attribute list
    var filteredAttributes = new SeparatedSyntaxList<AttributeSyntax>();

    foreach (var attr in node.Attributes)
    {
      if (!IsConditionalAttribute(attr))
      {
        filteredAttributes = filteredAttributes.Add(attr);
      }
    }

    if (filteredAttributes.Count == 0)
    {
      // Drop the entire attribute list when it only contained Conditional
      return null; // returning null will remove the node
    }

    var newNode = node.WithAttributes(filteredAttributes);
    return base.VisitAttributeList(newNode);
  }

  private static TMemberDeclarationSyntax WithEmbeddedAttribute<TMemberDeclarationSyntax>(TMemberDeclarationSyntax node)
    where TMemberDeclarationSyntax : MemberDeclarationSyntax
  {
    var lists = node.AttributeLists;
    var hasAttributeLists = lists.Any();

    var attributeSyntax = SyntaxFactory.Attribute(
      SyntaxFactory.AliasQualifiedName(
        SyntaxFactory.IdentifierName("global"),
        SyntaxFactory.IdentifierName("Microsoft.CodeAnalysis.EmbeddedAttribute")));
    var attributeList = SyntaxFactory.AttributeList(SyntaxFactory.SeparatedList([attributeSyntax]))
      .WithLeadingTrivia(SyntaxFactory.Space, SyntaxFactory.Space)
      .WithTrailingTrivia(SyntaxFactory.ElasticCarriageReturnLineFeed);

    lists = lists.Add(attributeList);

    if (!hasAttributeLists)
    {
      var leadingTrivia = node.GetLeadingTrivia();
      var leadingWhitespace = leadingTrivia.LastOrDefault(x => x.IsKind(SyntaxKind.WhitespaceTrivia));

      return (TMemberDeclarationSyntax)
        node.WithoutLeadingTrivia()
            .WithLeadingTrivia(leadingWhitespace)
            .WithAttributeLists(lists)
            .WithLeadingTrivia(leadingTrivia);
    }

    return (TMemberDeclarationSyntax)node.WithAttributeLists(lists);
  }

  public override SyntaxNode? VisitClassDeclaration(ClassDeclarationSyntax node)
  {
    var visited = (ClassDeclarationSyntax?)base.VisitClassDeclaration(node);
    if (visited is null) return null;

    visited = WithEmbeddedAttribute(visited);
    visited = ChangePublicToInternal(visited);
    return visited;
  }

  public override SyntaxNode? VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
  {
    var visited = (InterfaceDeclarationSyntax?)base.VisitInterfaceDeclaration(node);
    if (visited is null) return null;

    visited = WithEmbeddedAttribute(visited);
    visited = ChangePublicToInternal(visited);
    return visited;
  }

  public override SyntaxNode? VisitStructDeclaration(StructDeclarationSyntax node)
  {
    var visited = (StructDeclarationSyntax?)base.VisitStructDeclaration(node);
    if (visited is null) return null;

    visited = WithEmbeddedAttribute(visited);
    visited = ChangePublicToInternal(visited);
    return visited;
  }

  public override SyntaxNode? VisitEnumDeclaration(EnumDeclarationSyntax node)
  {
    var visited = (EnumDeclarationSyntax?)base.VisitEnumDeclaration(node);
    if (visited is null) return null;

    visited = WithEmbeddedAttribute(visited);
    visited = ChangePublicToInternal(visited);
    return visited;
  }

  public override SyntaxNode? VisitDelegateDeclaration(DelegateDeclarationSyntax node)
  {
    var visited = (DelegateDeclarationSyntax?)base.VisitDelegateDeclaration(node);
    if (visited is null) return null;

    visited = WithEmbeddedAttribute(visited);
    visited = ChangePublicToInternal(visited);
    return visited;
  }

  public override SyntaxNode? VisitRecordDeclaration(RecordDeclarationSyntax node)
  {
    var visited = (RecordDeclarationSyntax?)base.VisitRecordDeclaration(node);
    if (visited is null) return null;

    visited = WithEmbeddedAttribute(visited);
    visited = ChangePublicToInternal(visited);
    return visited;
  }

  private static bool IsConditionalAttribute(AttributeSyntax attribute)
  {
    var name = attribute.Name.ToString();
    return string.Equals(name, "Conditional", StringComparison.Ordinal);
  }

  private static TMemberDeclarationSyntax? ChangePublicToInternal<TMemberDeclarationSyntax>(TMemberDeclarationSyntax? node)
    where TMemberDeclarationSyntax : MemberDeclarationSyntax
  {
    if (node is null) return null;

    // check if this is a top-level type (not nested)
    if (IsNestedType(node)) return node;

    var modifiers = node.Modifiers;

    // find public modifier
    var publicModifier = modifiers.FirstOrDefault(m => m.IsKind(SyntaxKind.PublicKeyword));
    if (publicModifier.IsKind(SyntaxKind.None))
      return node;

    // Replace public with internal
    var internalToken = SyntaxFactory.Token(SyntaxKind.InternalKeyword)
      .WithLeadingTrivia(publicModifier.LeadingTrivia)
      .WithTrailingTrivia(publicModifier.TrailingTrivia);

    var newModifiersList = modifiers.Replace(publicModifier, internalToken);
    return (TMemberDeclarationSyntax)node.WithModifiers(newModifiersList);
  }

  private static bool IsNestedType(MemberDeclarationSyntax node)
  {
    var parent = node.Parent;
    while (parent != null)
    {
      if (parent is ClassDeclarationSyntax or StructDeclarationSyntax or InterfaceDeclarationSyntax or RecordDeclarationSyntax)
        return true;

      if (parent is NamespaceDeclarationSyntax or FileScopedNamespaceDeclarationSyntax or CompilationUnitSyntax)
        return false;

      parent = parent.Parent;
    }

    return false;
  }
}